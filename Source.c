#define HEX3_HEX0_BASE        0xFF200020
#define HEX5_HEX4_BASE        0xFF200030
#define SW_BASE               0xFF200040
#define _CRT_SECURE_NO_DEPRECATE

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <limits.h>


volatile int* lowerSeg = (int*)HEX3_HEX0_BASE;

volatile int DELAY_LENGTH; // volatile so it survives compilation

volatile int delay_count;


unsigned char lookupTable[] = { 0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x67 };

double dataset[] = { 0,9.56682,9.88763,9.63146,9.77151,9.89242,9.77032,9.94149,9.83496,9.74877,9.67934,9.60872,9.87326,9.84813,9.75236,9.82658,9.43275,9.58717,9.83376,9.97621,9.78468,9.88882,9.77271,9.71166,9.6566,9.5333,9.71765,9.79426,9.56203,9.62667,9.47105,9.62308,9.58477,9.75715,9.60872,9.32262,9.20292,8.56848,8.40688,8.7229,8.32308,7.65872,6.92852,6.66757,6.72143,6.02116,6.1265,7.06738,8.38653,8.82944,9.47704,10.12225,9.29868,11.08468,12.43734,13.2681,14.768,17.22674,17.7271,19.38861,18.93612,17.89709,15.90998,14.91404,13.87021,13.06579,9.79785,6.58497,4.48175,4.74151,2.45275,3.42356,4.34649,3.29189,6.60173,8.8845,7.85983,10.32934,10.83569,9.4914,9.49859,9.88045,9.54527,9.3322,9.27833,9.32382,8.70375,7.98432,6.94169,5.90983,4.71757,4.66251,5.03718,6.35394,6.31324,7.34749,10.1809,8.88809,8.62833,13.03826,11.42943,13.83789,17.51163,20.88253,19.34192,20.46715,19.27728,17.42305,14.67463,12.65281,12.40622,11.70475,8.73248,4.98691,5.55551,4.62181,3.47743,4.54639,4.90431,5.86075,7.1392,7.43487,7.7485,9.90798,10.04324,9.70568,10.04085,9.63146,9.51295,9.12271,7.99868,6.99077,6.816,5.95412,4.5428,4.08194,5.16527,5.16287,6.98598,9.08201,9.20292,9.70208,12.68633,13.68347,14.82546,17.4458,18.28254,18.71228,20.64312,17.8085,16.63899,15.59396,13.36386,12.28053,10.79858,8.61157,5.96729,5.02521,3.63664,3.31702,4.95459,5.86315,6.62208,6.34676,7.41931,9.6937,10.32814,9.76912,9.66019,9.74997,9.54527,9.67096,9.22446,8.55651,8.0334,7.25891,6.46646,6.14086,4.61462,5.88589,5.18682,4.10827,6.83036,9.95466,10.35208,11.50245,13.47519,13.66791,15.08402,19.7166,20.46236,17.83244,18.62609,16.97177,14.45198,14.06653,13.9959,10.49693,8.40927,7.83349,5.35201,4.0173,4.53921,4.40394,5.8811,6.97281,6.71545,5.99004,8.01185,9.93192,9.63625,10.07557,9.85411,9.64343,9.62787,9.22805,8.8043,8.54933,8.65946,7.83708,6.61729,5.70274,4.92586,5.17844,3.84851,4.15496,5.0719,7.13322,9.98818,11.67363,11.60779,12.40981,15.3366,17.15731,21.81623,20.97709,20.02663,20.75444,18.54589,14.57288,11.65447,11.32169,10.93265,9.38726,5.93856,4.77982,5.00367,3.82816,3.75514,5.16527,5.84998,6.41858,5.82604,8.1543,9.60153,9.9391,10.1845,9.9403,9.28431,10.17013,9.36212,8.42483,7.87299,7.08294,6.00799,5.13175,4.1801,4.35606,3.82218,4.10708,6.32521,7.93285,7.67548,10.55079,14.32868,14.16229,17.23871,19.82793,22.68528,20.71255,19.90454,17.933,16.23798,14.23771,12.66119,10.42869,8.81627,7.72815,5.34602,3.9742,4.66251,4.44584,4.49133,7.29482,7.82032,6.73939,6.49519,7.59049,9.97381,10.72796,9.94269,9.20651,9.91157,10.06599,9.99417,9.83855,9.09997,8.58763,8.09804,7.67787,7.35826,6.41379,5.34602,5.33764,4.26748,2.78673,4.63258,5.10063,6.05946,10.78781,13.11487,14.76441,16.60068,18.42738,22.26033,21.11356,21.85812,19.5957,15.94829,13.76008,14.04498,11.14333,8.57566,7.06977,6.2462,4.85044,3.99815,4.77024,5.28138,5.81766,6.65919,6.45449,6.45928,8.22852,9.58477,10.23717,10.15816,9.61111,9.6159,9.55245,9.54527,9.23643,9.331,9.18376,8.71332,7.99629,7.21941,6.68911,6.12889,6.28451,4.71159,4.36205,5.11739,5.4358,7.33791,8.05135,10.12225,11.66884,14.74645,19.56218,20.21577,21.30868,21.5409,21.83897,18.69911,14.25686,12.11893,12.27215,9.3298,8.59481,7.12843,4.53323,4.80136,4.97494,4.82291,6.08819,6.52392,8.14832,6.43294,7.23138,8.09564,8.90006,9.8182,9.91995,9.82658,9.37529,9.12032,9.06047,8.53616,8.69896,7.91728,6.2893,5.65366,4.9893,4.00772,3.48461,3.83535,5.04078,7.02189,8.74564,10.6693,11.95733,15.32822,17.5272,19.70343,18.30887,18.70988,20.65987,18.63686,16.60547,14.17067,13.05143,12.3344,9.98219,6.58257,6.4509,5.91821,3.35772,6.75495,8.1555,6.66038,5.20477,5.68239,6.03073,7.63478,9.98818,9.63625,8.50264,9.40402,9.69371,9.88164,9.84453,9.27833,8.60559,9.94269,9.01019,7.73174,7.65992,6.86747,5.29455,3.61748,4.43986,2.26961,2.29474,6.17797,6.00081,7.34629,12.96644,14.54774,14.77638,21.54569,21.07046,20.26126,27.02698,22.95462,15.28632,12.79646,13.58651,11.70116,9.18855,6.38626,5.10901,5.06831,4.06638,2.84419,3.48581,4.47696,7.33791,7.15955,7.02069,10.85843,9.72603,8.17824,10.29702,10.73155,9.36212,10.19168,10.80098,9.76074,9.46507,10.19886,9.46268,9.67336,10.47658,9.72842,9.47704,9.84573,9.72124,9.44113,9.6159,9.69849,9.85052,9.96304,9.81102,9.54168,9.80503,9.56323,9.70209,9.61709,9.61949,9.93312,9.80264,9.87925,9.72962,9.66139,9.6949,9.76433,9.70089,9.58238,10.07437,9.79306,9.80862 };

void DisplayHex(int value)
{


    *(lowerSeg) = lookupTable[value % 10];
    value /= 10;
    *((char*)lowerSeg + 1) = lookupTable[value % 10];
    value /= 10;
    *((char*)lowerSeg + 2) = lookupTable[value % 10];
    value /= 10;
    *((char*)lowerSeg + 3) = lookupTable[value % 10];


}

void ResetDisplay() {
    *(lowerSeg) = lookupTable[0];
    *((char*)lowerSeg + 1) = lookupTable[0];
    *((char*)lowerSeg + 2) = lookupTable[0];
    *((char*)lowerSeg + 3) = lookupTable[0];
}

int readSwitch(void) {
    volatile int* swPTR = (int*)SW_BASE;
    volatile int switchState = *swPTR;
    switchState = switchState & 0x1;
    return switchState;
}


int main() {
    DELAY_LENGTH = 7000;
    ResetDisplay();
    bool max = false, min = false;
    double upperLimit = INT_MIN, lowerLimit = INT_MAX; // default
    double tolerableDeviation = 0.3;
    double val1 = 0, val2 = 0;
    int reps = 0, i = 0;
    int length = sizeof(dataset) / sizeof(dataset[0]);


    while (i < length) {
        if (dataset[i] > upperLimit) {
            upperLimit = dataset[i];
        }
        if (dataset[i] < lowerLimit && dataset[i] > 4) { // 4 is here due to the start value iregularity of 0 from the measurements.
            lowerLimit = dataset[i];
        }
        i++;

       
    }

    printf("Max is %f and Min is %f \n", upperLimit, lowerLimit);

    i = 0;

    while (true)
    {
        if (!readSwitch() && i < length) {
            // Add some logic here to count rep
            if (dataset[i] <= upperLimit * (1 + tolerableDeviation) && dataset[i] >= upperLimit * (1 - tolerableDeviation)) {
                max = true;
                val1 = dataset[i];
            }

            if (dataset[i] <= lowerLimit * (1 + tolerableDeviation) && dataset[i] >= lowerLimit * (1 - tolerableDeviation) && max) {
                min = true;
                val2 = dataset[i];
                printf("The pair value is %f and %f \n", val1, val2);
            }

            if (max && min) {
                reps++;
                DisplayHex(reps);
                max = false;
                min = false;
            }
            i++;

        }
        else if (readSwitch()){
            ResetDisplay();
            i = 0;
            reps = 0;
        }

        

        for (delay_count = DELAY_LENGTH; delay_count != 0; --delay_count);
    }

    printf("The total rep is %d", reps);

    return 0;
}


